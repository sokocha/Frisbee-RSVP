import { kv } from '@vercel/kv';
import { Resend } from 'resend';
import PDFDocument from 'pdfkit';

const RSVP_KEY = 'frisbee-rsvp-data';
const SETTINGS_KEY = 'frisbee-settings';
const LAST_EMAIL_KEY = 'frisbee-last-email';

const resend = new Resend(process.env.RESEND_API_KEY);

// Generate PDF buffer from RSVP list
async function generatePDF(mainList, waitlist, weekId) {
  return new Promise((resolve, reject) => {
    const doc = new PDFDocument({ margin: 50 });
    const chunks = [];

    doc.on('data', chunk => chunks.push(chunk));
    doc.on('end', () => resolve(Buffer.concat(chunks)));
    doc.on('error', reject);

    // Title
    doc.fontSize(24).font('Helvetica-Bold').text('Weekly Frisbee RSVP List', { align: 'center' });
    doc.fontSize(12).font('Helvetica').text(`Week: ${weekId}`, { align: 'center' });
    doc.text(`Generated: ${new Date().toLocaleString('en-US', { timeZone: 'Africa/Lagos' })} WAT`, { align: 'center' });
    doc.moveDown(2);

    // Main List
    doc.fontSize(16).font('Helvetica-Bold').text(`Main List (${mainList.length} participants)`);
    doc.moveDown(0.5);

    if (mainList.length === 0) {
      doc.fontSize(11).font('Helvetica').text('No participants registered.');
    } else {
      mainList.forEach((person, index) => {
        const badge = person.isWhitelisted ? ' [AIS]' : '';
        doc.fontSize(11).font('Helvetica').text(`${index + 1}. ${person.name}${badge}`);
      });
    }

    doc.moveDown(1.5);

    // Waitlist
    if (waitlist.length > 0) {
      doc.fontSize(16).font('Helvetica-Bold').text(`Waitlist (${waitlist.length})`);
      doc.moveDown(0.5);

      waitlist.forEach((person, index) => {
        const badge = person.isWhitelisted ? ' [AIS]' : '';
        doc.fontSize(11).font('Helvetica').text(`${index + 1}. ${person.name}${badge}`);
      });
    }

    doc.moveDown(2);

    // Footer
    doc.fontSize(9).font('Helvetica').fillColor('#666666')
      .text('This list was automatically generated by the Frisbee RSVP system.', { align: 'center' });

    doc.end();
  });
}

// Get current week identifier
function getCurrentWeekId(timezone) {
  const now = new Date();
  const watTime = new Date(now.toLocaleString('en-US', { timeZone: timezone }));
  const year = watTime.getFullYear();
  const startOfYear = new Date(year, 0, 1);
  const days = Math.floor((watTime - startOfYear) / (24 * 60 * 60 * 1000));
  const weekNum = Math.ceil((days + startOfYear.getDay() + 1) / 7);
  return `${year}-W${weekNum.toString().padStart(2, '0')}`;
}

// Replace template variables
function replaceTemplateVars(template, vars) {
  let result = template;
  for (const [key, value] of Object.entries(vars)) {
    result = result.replace(new RegExp(`{{${key}}}`, 'g'), value);
  }
  return result;
}

export default async function handler(req, res) {
  // This endpoint can be called:
  // 1. Automatically when access period closes (internal call)
  // 2. Manually from admin dashboard (with auth)

  const authHeader = req.headers.authorization;
  const isInternalCall = req.headers['x-internal-call'] === process.env.RESEND_API_KEY;
  const ADMIN_PASSWORD = process.env.ADMIN_PASSWORD || 'frisbee-admin-2024';

  // Require auth for manual calls
  if (!isInternalCall && (!authHeader || authHeader !== `Bearer ${ADMIN_PASSWORD}`)) {
    return res.status(401).json({ error: 'Unauthorized' });
  }

  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const settings = await kv.get(SETTINGS_KEY);
    const emailSettings = settings?.email;

    if (!emailSettings?.enabled) {
      return res.status(400).json({ error: 'Email sending is not enabled' });
    }

    if (!emailSettings.recipients || emailSettings.recipients.length === 0) {
      return res.status(400).json({ error: 'No email recipients configured' });
    }

    if (!process.env.RESEND_API_KEY) {
      return res.status(500).json({ error: 'RESEND_API_KEY not configured' });
    }

    const rsvpData = await kv.get(RSVP_KEY) || { mainList: [], waitlist: [] };
    const timezone = settings?.accessPeriod?.timezone || 'Africa/Lagos';
    const weekId = getCurrentWeekId(timezone);

    // Check if we already sent email for this week (prevent duplicates)
    const lastEmail = await kv.get(LAST_EMAIL_KEY);
    const forceResend = req.body?.force === true;

    if (lastEmail === weekId && !forceResend) {
      return res.status(400).json({ error: 'Email already sent for this week. Use force=true to resend.' });
    }

    // Generate PDF
    const pdfBuffer = await generatePDF(rsvpData.mainList, rsvpData.waitlist, weekId);

    // Prepare template variables
    const templateVars = {
      week: weekId,
      count: rsvpData.mainList.length.toString(),
      waitlistCount: rsvpData.waitlist.length.toString(),
      date: new Date().toLocaleDateString('en-US', {
        timeZone: timezone,
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      })
    };

    const subject = replaceTemplateVars(emailSettings.subject, templateVars);
    const body = replaceTemplateVars(emailSettings.body, templateVars);

    // Send email
    const { data, error } = await resend.emails.send({
      from: 'Frisbee RSVP <noreply@itsplayday.com>',
      to: emailSettings.recipients,
      subject: subject,
      text: body,
      attachments: [
        {
          filename: `frisbee-rsvp-${weekId}.pdf`,
          content: pdfBuffer.toString('base64'),
        },
      ],
    });

    if (error) {
      console.error('Failed to send email:', error);
      return res.status(500).json({ error: 'Failed to send email', details: error.message });
    }

    // Mark as sent
    await kv.set(LAST_EMAIL_KEY, weekId);

    return res.status(200).json({
      success: true,
      message: `Email sent to ${emailSettings.recipients.length} recipient(s)`,
      emailId: data?.id,
      weekId
    });

  } catch (error) {
    console.error('Send list error:', error);
    return res.status(500).json({ error: 'Failed to send list', details: error.message });
  }
}
