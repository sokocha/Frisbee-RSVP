import { Resend } from 'resend';
import PDFDocument from 'pdfkit';
import { getOrganizationBySlug } from '../../../../lib/organizations';
import { getOrgData, setOrgData, ORG_KEY_SUFFIXES } from '../../../../lib/kv';
import { verifySession, parseCookies, isSuperAdmin } from '../../../../lib/auth';
import { getOrganizerById, organizerOwnsOrg } from '../../../../lib/organizations';

const resend = process.env.RESEND_API_KEY ? new Resend(process.env.RESEND_API_KEY) : null;

// Default settings
function getDefaultSettings(timezone = 'Africa/Lagos') {
  return {
    mainListLimit: 30,
    email: {
      enabled: false,
      recipients: [],
      cc: [],
      bcc: [],
      subject: 'Weekly RSVP List - {{week}}',
      body: 'Please find attached the RSVP list for this week.\n\nTotal participants: {{count}}'
    }
  };
}

// Get current week identifier
function getCurrentWeekId(timezone) {
  const now = new Date();
  const localTime = new Date(now.toLocaleString('en-US', { timeZone: timezone }));
  const year = localTime.getFullYear();
  const startOfYear = new Date(year, 0, 1);
  const days = Math.floor((localTime - startOfYear) / (24 * 60 * 60 * 1000));
  const weekNum = Math.ceil((days + startOfYear.getDay() + 1) / 7);
  return `${year}-W${weekNum.toString().padStart(2, '0')}`;
}

// Replace template variables
function replaceTemplateVars(template, vars) {
  let result = template;
  for (const [key, value] of Object.entries(vars)) {
    result = result.replace(new RegExp(`{{${key}}}`, 'g'), value);
  }
  return result;
}

// Generate PDF buffer from RSVP list
async function generatePDF(mainList, weekId, orgName, sport) {
  return new Promise((resolve, reject) => {
    const doc = new PDFDocument({ margin: 50 });
    const chunks = [];

    doc.on('data', chunk => chunks.push(chunk));
    doc.on('end', () => resolve(Buffer.concat(chunks)));
    doc.on('error', reject);

    // Title
    doc.fontSize(24).font('Helvetica-Bold').text(`${orgName} RSVP List`, { align: 'center' });
    if (sport) {
      doc.fontSize(14).font('Helvetica').text(sport, { align: 'center' });
    }
    doc.fontSize(12).font('Helvetica').text(`Week: ${weekId}`, { align: 'center' });
    doc.text(`Generated: ${new Date().toLocaleString('en-US', { timeZone: 'Africa/Lagos' })} WAT`, { align: 'center' });
    doc.moveDown(2);

    // Sort list alphabetically by name
    const sortedMainList = [...mainList].sort((a, b) => a.name.localeCompare(b.name));

    // Main List
    doc.fontSize(16).font('Helvetica-Bold').text(`Participants (${mainList.length})`);
    doc.moveDown(0.5);

    if (sortedMainList.length === 0) {
      doc.fontSize(11).font('Helvetica').text('No participants registered.');
    } else {
      sortedMainList.forEach((person, index) => {
        const badge = person.isWhitelisted ? ' [VIP]' : '';
        doc.fontSize(11).font('Helvetica').text(`${index + 1}. ${person.name}${badge}`);
      });
    }

    doc.moveDown(2);

    // Footer
    doc.fontSize(9).font('Helvetica').fillColor('#666666')
      .text('This list was automatically generated by PlayDay RSVP.', { align: 'center' });

    doc.end();
  });
}

// Update email status in KV store
async function updateEmailStatus(orgId, weekId, status, details = {}) {
  const statusData = {
    weekId,
    status, // 'pending', 'sent', 'failed'
    updatedAt: new Date().toISOString(),
    ...details
  };
  await setOrgData(orgId, ORG_KEY_SUFFIXES.EMAIL_STATUS, statusData);
  return statusData;
}

export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  const { slug } = req.query;

  // Get organization
  const org = await getOrganizationBySlug(slug);
  if (!org) {
    return res.status(404).json({ error: 'Organization not found' });
  }

  const orgId = org.id;

  // Check for authentication - either cron secret or organizer session
  const authHeader = req.headers.authorization;
  const isCronCall = authHeader === `Bearer ${process.env.CRON_SECRET}`;
  let authenticatedOrganizer = null;

  if (!isCronCall) {
    // Require organizer authentication
    const cookies = parseCookies(req);
    const sessionToken = cookies.session;

    if (!sessionToken) {
      return res.status(401).json({ error: 'Not authenticated' });
    }

    const organizerId = await verifySession(sessionToken);
    if (!organizerId) {
      return res.status(401).json({ error: 'Invalid or expired session' });
    }

    const organizer = await getOrganizerById(organizerId);
    if (!organizer) {
      return res.status(403).json({ error: 'Organizer not found' });
    }

    authenticatedOrganizer = organizer;

    const isAdmin = isSuperAdmin(organizer.email);
    if (organizer.status !== 'approved' && !isAdmin) {
      return res.status(403).json({ error: 'Account not approved' });
    }

    const hasPermission = isAdmin || await organizerOwnsOrg(organizerId, orgId);
    if (!hasPermission) {
      return res.status(403).json({ error: 'You do not have permission to manage this organization' });
    }
  }

  try {
    const settings = await getOrgData(orgId, ORG_KEY_SUFFIXES.SETTINGS, getDefaultSettings(org.timezone));
    const emailSettings = settings?.email;
    const isTestEmail = req.body?.test === true;

    // For test emails, we only need an authenticated organizer with an email
    if (isTestEmail) {
      if (!authenticatedOrganizer || !authenticatedOrganizer.email) {
        return res.status(400).json({ error: 'Cannot send test email: organizer email not found' });
      }

      if (!resend) {
        return res.status(500).json({ error: 'Email service not configured' });
      }

      const rsvpData = await getOrgData(orgId, ORG_KEY_SUFFIXES.RSVP_DATA, { mainList: [], waitlist: [] });
      const timezone = settings?.accessPeriod?.timezone || org.timezone || 'Africa/Lagos';
      const weekId = getCurrentWeekId(timezone);

      // Generate PDF (main list only)
      const pdfBuffer = await generatePDF(rsvpData.mainList, weekId, org.name, org.sport);

      // Create list of names for template
      const namesList = rsvpData.mainList
        .sort((a, b) => a.name.localeCompare(b.name))
        .map((p, i) => `${i + 1}. ${p.name}`)
        .join('\n');

      // Prepare template variables
      const templateVars = {
        week: weekId,
        org: org.name,
        sport: org.sport || '',
        count: rsvpData.mainList.length.toString(),
        waitlistCount: rsvpData.waitlist.length.toString(),
        list: namesList,
        date: new Date().toLocaleDateString('en-US', {
          timeZone: timezone,
          weekday: 'long',
          year: 'numeric',
          month: 'long',
          day: 'numeric'
        })
      };

      const testSubject = `[TEST] ${replaceTemplateVars(emailSettings?.subject || 'Weekly RSVP List - {{week}}', templateVars)}`;
      const testBody = `This is a TEST email. The actual email will be sent to your configured recipients.\n\n---\n\n${replaceTemplateVars(emailSettings?.body || 'Please find attached the RSVP list for this week.\n\nTotal participants: {{count}}', templateVars)}`;

      // Build test email options - send only to the organizer
      const testEmailOptions = {
        from: `${org.name} <noreply@itsplayday.com>`,
        to: [authenticatedOrganizer.email],
        subject: testSubject,
        text: testBody,
        attachments: [
          {
            filename: `${org.slug}-rsvp-${weekId}.pdf`,
            content: pdfBuffer.toString('base64'),
          },
        ],
      };

      // Send test email
      const { data, error } = await resend.emails.send(testEmailOptions);

      if (error) {
        console.error(`[${org.slug}] Failed to send test email:`, error);
        return res.status(500).json({ error: 'Failed to send test email', details: error.message });
      }

      console.log(`[${org.slug}] Test email sent to ${authenticatedOrganizer.email}`);

      return res.status(200).json({
        success: true,
        message: `Test email sent to ${authenticatedOrganizer.email}`,
        emailId: data?.id,
        weekId,
        isTest: true
      });
    }

    // Regular email sending logic
    if (!emailSettings?.enabled) {
      return res.status(400).json({ error: 'Email sending is not enabled', skipped: true });
    }

    if (!emailSettings.recipients || emailSettings.recipients.length === 0) {
      return res.status(400).json({ error: 'No email recipients configured', skipped: true });
    }

    if (!resend) {
      return res.status(500).json({ error: 'Email service not configured' });
    }

    const rsvpData = await getOrgData(orgId, ORG_KEY_SUFFIXES.RSVP_DATA, { mainList: [], waitlist: [] });
    const timezone = settings?.accessPeriod?.timezone || org.timezone || 'Africa/Lagos';
    const weekId = getCurrentWeekId(timezone);

    // Check if we already sent email for this week (prevent duplicates)
    const lastEmail = await getOrgData(orgId, ORG_KEY_SUFFIXES.LAST_EMAIL, null);
    const forceResend = req.body?.force === true;

    if (lastEmail === weekId && !forceResend) {
      return res.status(200).json({
        message: 'Email already sent for this week',
        skipped: true,
        weekId
      });
    }

    // Generate PDF (main list only)
    const pdfBuffer = await generatePDF(rsvpData.mainList, weekId, org.name, org.sport);

    // Create list of names for template
    const namesList = rsvpData.mainList
      .sort((a, b) => a.name.localeCompare(b.name))
      .map((p, i) => `${i + 1}. ${p.name}`)
      .join('\n');

    // Prepare template variables
    const templateVars = {
      week: weekId,
      org: org.name,
      sport: org.sport || '',
      count: rsvpData.mainList.length.toString(),
      waitlistCount: rsvpData.waitlist.length.toString(),
      list: namesList,
      date: new Date().toLocaleDateString('en-US', {
        timeZone: timezone,
        weekday: 'long',
        year: 'numeric',
        month: 'long',
        day: 'numeric'
      })
    };

    const subject = replaceTemplateVars(emailSettings.subject, templateVars);
    const body = replaceTemplateVars(emailSettings.body, templateVars);

    // Build email options
    const emailOptions = {
      from: `${org.name} <noreply@itsplayday.com>`,
      to: emailSettings.recipients,
      subject: subject,
      text: body,
      attachments: [
        {
          filename: `${org.slug}-rsvp-${weekId}.pdf`,
          content: pdfBuffer.toString('base64'),
        },
      ],
    };

    // Add CC if configured
    if (emailSettings.cc && emailSettings.cc.length > 0) {
      emailOptions.cc = emailSettings.cc;
    }

    // Add BCC if configured
    if (emailSettings.bcc && emailSettings.bcc.length > 0) {
      emailOptions.bcc = emailSettings.bcc;
    }

    // Send email
    const { data, error } = await resend.emails.send(emailOptions);

    if (error) {
      console.error(`[${org.slug}] Failed to send email:`, error);
      await updateEmailStatus(orgId, weekId, 'failed', {
        error: error.message,
        recipientCount: emailSettings.recipients.length,
        attemptedAt: new Date().toISOString()
      });
      return res.status(500).json({ error: 'Failed to send email', details: error.message });
    }

    // Mark as sent
    await setOrgData(orgId, ORG_KEY_SUFFIXES.LAST_EMAIL, weekId);

    const ccCount = emailSettings.cc?.length || 0;
    const bccCount = emailSettings.bcc?.length || 0;
    let message = `Email sent to ${emailSettings.recipients.length} recipient(s)`;
    if (ccCount > 0) message += `, ${ccCount} CC`;
    if (bccCount > 0) message += `, ${bccCount} BCC`;

    // Track successful status
    await updateEmailStatus(orgId, weekId, 'sent', {
      emailId: data?.id,
      sentAt: new Date().toISOString(),
      recipientCount: emailSettings.recipients.length,
      ccCount,
      bccCount,
      mainListCount: rsvpData.mainList.length,
      waitlistCount: rsvpData.waitlist.length
    });

    console.log(`[${org.slug}] ${message}`);

    return res.status(200).json({
      success: true,
      message,
      emailId: data?.id,
      weekId
    });

  } catch (error) {
    console.error(`[${org.slug}] Send list error:`, error);
    return res.status(500).json({ error: 'Failed to send list', details: error.message });
  }
}
